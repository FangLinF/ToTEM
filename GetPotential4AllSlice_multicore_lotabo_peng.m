function potential=GetPotential4AllSlice_multicore_lotabo_peng(green_Ncol, green_Nrow,... 
    ele_n, absorp_n, ....仅有离子或者原子的弹性和吸收
    ele_n_i, absorp_n_i, ... %原子或原子+离子，弹性或者吸收
    series_n, series_n_i, ...  %原子排列次序
    s2, gx_green, gy_green, ...
    sigma, PARAMETER, APERTURE,paraflag);   %为了STEM计算不出错，这里只带入到HRTEM和CBED。
%paraflag 表示用lotabo还是peng的方法计算势场
potential=zeros(green_Ncol, green_Nrow, max(length(series_n), length(series_n_i)));  %每层势场都存下来
k1=0; %记录从哪个原子开始计算势场。
k2=0;
beg1(1)=0;
if ~isempty(series_n)
    for i=1:length(series_n);
        beg1(i+1)=sum(series_n(1:i));
    end
end
beg2(1)=0;
if ~isempty(series_n_i)
    for i=1:length(series_n_i);
         beg2(i+1)=sum(series_n_i(1:i));
    end
end
%acpu=cputime;
mypar=parpool;
if paraflag == 'p'
      %先算ele_n的矩阵
      if ~isempty(series_n)
          parfor i=1:length(series_n);  %计算每一层的势场    
               i
               for atom_i=beg1(i)+1:sum(series_n(1:i));
                   %k1=sum(series_n(1:i));  %为下一层，更新计算的原子的起始序数
                   if ~isempty(ele_n)&isempty(absorp_n)
                   %仅仅计算原子或离子的弹性势场，并没有考虑分层比例;
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3).*...
                           ( ele_n(atom_i,4).*exp(-s2.*ele_n(atom_i,5)) ...
                           +ele_n(atom_i,6).*exp(-s2.*ele_n(atom_i,7)) ...
                           +ele_n(atom_i,8).*exp(-s2.*ele_n(atom_i,9)) ...
                           +ele_n(atom_i,10).*exp(-s2.*ele_n(atom_i,11)) ...
                           +ele_n(atom_i,12).*exp(-s2.*ele_n(atom_i,13)) ) ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   elseif ~isempty(ele_n)&~isempty(absorp_n)
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3)*...
                          ( ele_n(atom_i,4).*exp(-s2.*ele_n(atom_i,5)) ...
                          +ele_n(atom_i,6).*exp(-s2.*ele_n(atom_i,7)) ...
                          +ele_n(atom_i,8).*exp(-s2.*ele_n(atom_i,9)) ...
                          +ele_n(atom_i,10).*exp(-s2.*ele_n(atom_i,11)) ...
                          +ele_n(atom_i,12).*exp(-s2.*ele_n(atom_i,13))  ...
                          +sqrt(-1)*( absorp_n(atom_i,1).*exp(-s2.*absorp_n(atom_i,2)) ...
                          +absorp_n(atom_i,3).*exp(-s2.*absorp_n(atom_i,4)) ...
                          +absorp_n(atom_i,5).*exp(-s2.*absorp_n(atom_i,6)) ...
                          +absorp_n(atom_i,7).*exp(-s2.*absorp_n(atom_i,8)) ...
                          +absorp_n(atom_i,9).*exp(-s2.*absorp_n(atom_i,10)) )) ...
                          .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   end
               end
          end
      end
      if ~isempty(series_n_i)
          parfor i=1:length(series_n_i);  %计算每一层的势场 
                 i
             for atom_i=beg1(i)+1:sum(series_n_i(1:i));
                 %k2=sum(series_n_i(1:i));  %为下一层，更新计算的原子的起始序数
                 if ~isempty(ele_n_i) & isempty(absorp_n_i)    %考虑原子和离子性的贡献比例
                      potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*exp(-s2.*ele_n_i(atom_i,6)) ...
                           +ele_n_i(atom_i,7).*exp(-s2.*ele_n_i(atom_i,8)) ...
                           +ele_n_i(atom_i,9).*exp(-s2.*ele_n_i(atom_i,10)) ...
                           +ele_n_i(atom_i,11).*exp(-s2.*ele_n_i(atom_i,12)) ...
                           +ele_n_i(atom_i,13).*exp(-s2.*ele_n_i(atom_i,14)) ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*exp(-s2.*ele_n_i(atom_i,17)) ...
                           +ele_n_i(atom_i,18).*exp(-s2.*ele_n_i(atom_i,19)) ...
                           +ele_n_i(atom_i,20).*exp(-s2.*ele_n_i(atom_i,21)) ...
                           +ele_n_i(atom_i,22).*exp(-s2.*ele_n_i(atom_i,23)) ...
                           +ele_n_i(atom_i,24).*exp(-s2.*ele_n_i(atom_i,25)) )) ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 elseif ~isempty(ele_n_i) & ~isempty(absorp_n_i)
                        potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*exp(-s2.*ele_n_i(atom_i,6)) ...
                           +ele_n_i(atom_i,7).*exp(-s2.*ele_n_i(atom_i,8)) ...
                           +ele_n_i(atom_i,9).*exp(-s2.*ele_n_i(atom_i,10)) ...
                           +ele_n_i(atom_i,11).*exp(-s2.*ele_n_i(atom_i,12)) ...
                           +ele_n_i(atom_i,13).*exp(-s2.*ele_n_i(atom_i,14)) ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*exp(-s2.*ele_n_i(atom_i,17)) ...
                           +ele_n_i(atom_i,18).*exp(-s2.*ele_n_i(atom_i,19)) ...
                           +ele_n_i(atom_i,20).*exp(-s2.*ele_n_i(atom_i,21)) ...
                           +ele_n_i(atom_i,22).*exp(-s2.*ele_n_i(atom_i,23)) ...
                           +ele_n_i(atom_i,24).*exp(-s2.*ele_n_i(atom_i,25)) ) ...
                           + sqrt(-1)*( absorp_n_i(atom_i,1).*exp(-s2.*absorp_n_i(atom_i,2)) ...
                           +absorp_n_i(atom_i,3).*exp(-s2.*absorp_n_i(atom_i,4)) ...
                           +absorp_n_i(atom_i,5).*exp(-s2.*absorp_n_i(atom_i,6)) ...
                           +absorp_n_i(atom_i,7).*exp(-s2.*absorp_n_i(atom_i,8)) ...
                           +absorp_n_i(atom_i,9).*exp(-s2.*absorp_n_i(atom_i,10))))...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 end
             end
          end
      end
end

if paraflag == 'l'
    g2=s2*4;
      %先算ele_n的矩阵
      if ~isempty(series_n)
          parfor i=1:length(series_n);  %计算每一层的势场    
               i
               for atom_i=beg1(i)+1:sum(series_n(1:i));
                   %k1=sum(series_n(1:i));  %为下一层，更新计算的原子的起始序数
                   if ~isempty(ele_n)&isempty(absorp_n)
                   %仅仅计算原子或离子的弹性势场，并没有考虑分层比例;
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3).*...
                           ( ele_n(atom_i,4).*(2+ele_n(atom_i,5)*g2)./(1+ele_n(atom_i,5).*g2).^2 ...
                           +ele_n(atom_i,6).*(2+ele_n(atom_i,7)*g2)./(1+ele_n(atom_i,7).*g2).^2 ...
                           +ele_n(atom_i,8).*(2+ele_n(atom_i,9)*g2)./(1+ele_n(atom_i,9).*g2).^2 ...
                           +ele_n(atom_i,10).*(2+ele_n(atom_i,11)*g2)./(1+ele_n(atom_i,11).*g2).^2 ...
                           +ele_n(atom_i,12).*(2+ele_n(atom_i,13)*g2)./(1+ele_n(atom_i,13).*g2).^2 ) ...
                           .*exp(-s2.*ele_n(atom_i,end))...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   elseif ~isempty(ele_n)&~isempty(absorp_n)
                       potential(:,:,i)=potential(:,:,i)+PARAMETER*ele_n(atom_i,3)*...
                          ( ( ele_n(atom_i,4).*(2+ele_n(atom_i,5)*g2)./(1+ele_n(atom_i,5).*g2).^2 ...
                           +ele_n(atom_i,6).*(2+ele_n(atom_i,7)*g2)./(1+ele_n(atom_i,7).*g2).^2 ...
                           +ele_n(atom_i,8).*(2+ele_n(atom_i,9)*g2)./(1+ele_n(atom_i,9).*g2).^2 ...
                           +ele_n(atom_i,10).*(2+ele_n(atom_i,11)*g2)./(1+ele_n(atom_i,11).*g2).^2 ...
                           +ele_n(atom_i,12).*(2+ele_n(atom_i,13)*g2)./(1+ele_n(atom_i,13).*g2).^2 ) ...
                           .*exp(-s2.*ele_n(atom_i,end))  ...
                          +sqrt(-1)*( absorp_n(atom_i,1).*exp(-s2.*absorp_n(atom_i,2)) ...
                          +absorp_n(atom_i,3).*exp(-s2.*absorp_n(atom_i,4)) ...
                          +absorp_n(atom_i,5).*exp(-s2.*absorp_n(atom_i,6)) ...
                          +absorp_n(atom_i,7).*exp(-s2.*absorp_n(atom_i,8)) ...
                          +absorp_n(atom_i,9).*exp(-s2.*absorp_n(atom_i,10)) )) ...
                          .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n(atom_i,1) + gy_green*ele_n(atom_i,2)));
                   end
               end
          end
      end
      if ~isempty(series_n_i)
          parfor i=1:length(series_n_i);  %计算每一层的势场 
                 i
             for atom_i=beg1(i)+1:sum(series_n_i(1:i));
                 %k2=sum(series_n_i(1:i));  %为下一层，更新计算的原子的起始序数
                 if ~isempty(ele_n_i) & isempty(absorp_n_i)    %考虑原子和离子性的贡献比例
                      potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*(ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*(2+ele_n_i(atom_i,6)*g2)./(1+ele_n_i(atom_i,6).*g2).^2 ...
                           +ele_n_i(atom_i,7).*(2+ele_n_i(atom_i,8)*g2)./(1+ele_n_i(atom_i,8).*g2).^2 ...
                           +ele_n_i(atom_i,9).*(2+ele_n_i(atom_i,10)*g2)./(1+ele_n_i(atom_i,10).*g2).^2 ...
                           +ele_n_i(atom_i,11).*(2+ele_n_i(atom_i,12)*g2)./(1+ele_n_i(atom_i,12).*g2).^2 ...
                           +ele_n_i(atom_i,13).*(2+ele_n_i(atom_i,14)*g2)./(1+ele_n_i(atom_i,14).*g2).^2 ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*(2+ele_n_i(atom_i,17)*g2)./(1+ele_n_i(atom_i,17).*g2).^2 ...
                           +ele_n_i(atom_i,18).*(2+ele_n_i(atom_i,19)*g2)./(1+ele_n_i(atom_i,19).*g2).^2 ...
                           +ele_n_i(atom_i,20).*(2+ele_n_i(atom_i,21)*g2)./(1+ele_n_i(atom_i,21).*g2).^2 ...
                           +ele_n_i(atom_i,22).*(2+ele_n_i(atom_i,23)*g2)./(1+ele_n_i(atom_i,23).*g2).^2 ...
                           +ele_n_i(atom_i,24).*(2+ele_n_i(atom_i,25)*g2)./(1+ele_n_i(atom_i,25).*g2).^2 )) ...
                           .*exp(-s2.*ele_n_i(atom_i,end))  ...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 elseif ~isempty(ele_n_i) & ~isempty(absorp_n_i)
                        potential(:,:,i)=potential(:,:,i)+PARAMETER* ele_n_i(atom_i,3)*( (ele_n_i(atom_i,4).*...
                           ( ele_n_i(atom_i,5).*(2+ele_n_i(atom_i,6)*g2)./(1+ele_n_i(atom_i,6).*g2).^2 ...
                           +ele_n_i(atom_i,7).*(2+ele_n_i(atom_i,8)*g2)./(1+ele_n_i(atom_i,8).*g2).^2 ...
                           +ele_n_i(atom_i,9).*(2+ele_n_i(atom_i,10)*g2)./(1+ele_n_i(atom_i,10).*g2).^2 ...
                           +ele_n_i(atom_i,11).*(2+ele_n_i(atom_i,12)*g2)./(1+ele_n_i(atom_i,12).*g2).^2 ...
                           +ele_n_i(atom_i,13).*(2+ele_n_i(atom_i,14)*g2)./(1+ele_n_i(atom_i,14).*g2).^2 ) ...
                           + ele_n_i(atom_i,15).*...
                           ( ele_n_i(atom_i,16).*(2+ele_n_i(atom_i,17)*g2)./(1+ele_n_i(atom_i,17).*g2).^2 ...
                           +ele_n_i(atom_i,18).*(2+ele_n_i(atom_i,19)*g2)./(1+ele_n_i(atom_i,19).*g2).^2 ...
                           +ele_n_i(atom_i,20).*(2+ele_n_i(atom_i,21)*g2)./(1+ele_n_i(atom_i,21).*g2).^2 ...
                           +ele_n_i(atom_i,22).*(2+ele_n_i(atom_i,23)*g2)./(1+ele_n_i(atom_i,23).*g2).^2 ...
                           +ele_n_i(atom_i,24).*(2+ele_n_i(atom_i,25)*g2)./(1+ele_n_i(atom_i,25).*g2).^2 )) ...
                           .*exp(-s2.*ele_n_i(atom_i,end))  ...
                           + sqrt(-1)*( absorp_n_i(atom_i,1).*exp(-s2.*absorp_n_i(atom_i,2)) ...
                           +absorp_n_i(atom_i,3).*exp(-s2.*absorp_n_i(atom_i,4)) ...
                           +absorp_n_i(atom_i,5).*exp(-s2.*absorp_n_i(atom_i,6)) ...
                           +absorp_n_i(atom_i,7).*exp(-s2.*absorp_n_i(atom_i,8)) ...
                           +absorp_n_i(atom_i,9).*exp(-s2.*absorp_n_i(atom_i,10))) )...
                           .*exp(-2*pi*sqrt(-1)*(gx_green*ele_n_i(atom_i,1) + gy_green*ele_n_i(atom_i,2)));
                 end
             end
          end
      end
end

delete(mypar)
%bcpu=cputime

for i=1:max(length(series_n), length(series_n_i))   %需要乘相互作用常数
    potentialsave(:,:,i)=ifft2(ifftshift(potential(:,:,i).*APERTURE))*green_Ncol*green_Nrow;
    potential(:,:,i)=exp(sqrt(-1)*potentialsave(:,:,i)*sigma./1000);  %根据kirkland数值的关系，sigma的单位是/千伏*A
end
return;